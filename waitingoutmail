#!/bin/bash

#tmpfile=$(mktemp)
#declare -p >"$tmpfile"

##############################################################
#                     waitingoutmail                         #
# (c) 2018 waldo kitty (wkitty42) aka mark lewis             #
#                                                            #
# This program is free software: you can redistribute it     #
# and/or modify it under the terms of the GNU General Public #
# License as published by the Free Software Foundation,      #
# either version 2 of the License, or (at your option) any   #
# later version.                                             #
#                                                            #
# This program is distributed in the hope that it will be    #
# useful, but WITHOUT ANY WARRANTY; without even the implied #
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR    #
# PURPOSE.  See the GNU General Public License for more      #
# details.                                                   #
#                                                            #
# You should have received a copy of the GNU General Public  #
# License along with this program.  If not, see              #
# <https://www.gnu.org/licenses/>.                           #
#                                                            #
##############################################################
#                                                            #
# waitingmail is a simple (ha!) bash script to monitor a FTN #
# (Fidonet Technology Network BSO (Binkley-Style Outbound)   #
# directory structure used by FTN mailers to send waiting    #
# mail to other FTN systems.                                 #
#                                                            #
# currently waitingoutmail expects a 5D directory structure  #
# where each secondary FTN domain has its own outbound       #
# directory and each directory has an extension representing #
# the HEX value of the FTN's zone. this depends highly on    #
# how your FTN mail tosser creates and manages the BSO. Both #
# tosser and mailer must work together or mail will not be   #
# transported as desired.                                    #
#                                                            #
# eg:                                                        #
# 1st FTN address: 1:123/456@fidonet                         #
# 2nd FTN address: 27:321/654@foobar                         #
# 3rd FTN address: 432:987/345@riptide                       #
# 4th FTN address: 999:76/785@yanknet                        #
#                                                            #
# /bbs/ftn/out/fidonet                                       #
# /bbs/ftn/out/foobar.01b                                    #
# /bbs/ftn/out/riptide.1b0                                   #
# /bbs/ftn/out/yanknet.3e7                                   #
#                                                            #
##############################################################


# first set your system's path and default zone variables
SBBSDIR='/sbbs'
SBBSFTNOUTBASE="$SBBSDIR/ftn/out/*"
#FTNDEFAULTNETWORK='fidonet'
FTNDEFAULTZONE='001'


###############################
# Do not edit below this line #
###############################
# set the logging and current directory variables
THISVERSION=0.0.2
SCRIPTNAME=$(basename "$0")
LOGFILE=$0.log
CWD=$PWD


#===  FUNCTION  ================================================================
#         NAME: elapsedtime
#  DESCRIPTION: calculate elapsed time from unix timestamp
#   PARAMETERS: 1 - the unix timestamp
#      RETURNS: Nothing; outputs days, hours, minutes, seconds
#===============================================================================
function elapsedtime () {
  local T=$1
  local D=$((T/60/60/24))
  local H=$((T/60/60%24))
  local M=$((T/60%60))
  local S=$((T%60))

  if (( D > 0 )); then
    printf "%s day" $D
    if (( D == 0 )) || (( D > 1 )); then printf "s"
    fi
    printf " "
  fi
  if (( H > 0 )); then
    if (( H >= 0 )) && (( H <= 9 )); then
      printf "0"
    fi
    printf "%s:" $H
  fi
  if (( M > 0 )); then
    if (( M >= 0 )) && (( M <= 9 )); then
      printf "0"
    fi
    printf "%s:" $M
  fi
  if (( S >= 0 )) && (( S <= 9 )); then
    printf "0"
  fi
  printf "%s" $S
}

#===  FUNCTION  ================================================================
#         NAME: rotate
#  DESCRIPTION: rotate files keeping 10 newest
#   PARAMETERS: 1 - the exceeded file size, in megabytes, to rotate file
#               2 - the full path of base file name to be rotated
#      RETURNS: last result code
# BORROWED FROM https://stackoverflow.com/questions/3690015/bash-script-log-file-rotation
#===============================================================================
function rotate () {
  # minimum file size to rotate in MBi:
  local MB="$1"
  # filename to rotate (full path)
  local F="$2"
  local msize="$((1024*1024*MB))"
  test -e "$F" || return 2

  local D
  D="$(dirname "$F")"
  local E=${F##*.}
  local B
  B="$(basename "$F" ."$E")"

  local s=

#  printf "** rotate msize=$msize file=$F -> $D | $B | $E\n"
  if [ "$(stat --printf %s "$F")" -ge $msize ] ; then
     for i in 8 7 6 5 4 3 2 1 0; do
       s="$D/$B-$i.$E"
       test -e "$s" && mv "$s" "$D/$B-$((i+1)).$E"
       # emtpy command is need to avoid exit iteration if test fails:
       :;
     done &&
     mv "$F" "$D"/"$B"-0."$E"
#  else
#     printf "** rotate skip: $F < $msize, skip\n"
  fi
  return $?
}

#===  FUNCTION  ================================================================
#         NAME: strindex
#  DESCRIPTION: calculated position of substring in given string
#   PARAMETERS: 1 - the text string to search
#               2 - the substring to find
#      RETURNS: zero based position of substring or -1 if substr not in string
# BORROWED FROM https://stackoverflow.com/questions/5031764/position-of-a-string-within-a-string-using-linux-shell-script
#===============================================================================
strindex() { 
  x="${1%%$2*}"
  [[ "$x" = "$1" ]] && echo -1 || echo "${#x}"
}

#===  FUNCTION  ================================================================
#         NAME: pad
#  DESCRIPTION: Pad $text on the $side with $char characters to length $length
#   PARAMETERS: 1 - the text string to pad (no default)
#               2 - how long the padded string is to be (default 80)
#               3 - the character to pad with (default '-')
#               4 - the side to pad on, L or R  or C for centre (default R)
#      RETURNS: Nothing
# BORROWED FROM http://hackerpublicradio.org/eps/hpr1757_full_shownotes.html
#===============================================================================
pad () {
  local text=${1?Usage: pad text [length] [character] [L|R|C]}
  local length=${2:-80}
  local char=${3:--}
  local side=${4:-R}
  local line l2

  [ ${#text} -ge "$length" ] && { echo "$text"; return; }

  char=${char:0:1}
  side=${side^^}

  printf -v line "%*s" $((length - ${#text})) ' '
  line=${line// /$char}

  if [[ $side == "R" ]]; then
    echo "${text}${line}"
  elif [[ $side == "L" ]]; then
    echo "${line}${text}"
  elif [[ $side == "C" ]]; then
    l2=$((${#line}/2))
    echo "${line:0:$l2}${text}${line:$l2}"
  fi
}

# rotate the log file before we start using it
rotate 0 "$LOGFILE"

# capture all output to a log file
# Redirect stdout ( > ) into a named pipe ( >() ) running "tee"
exec > >(tee "$LOGFILE")

# Without this, only stdout would be captured - i.e. your
# log file would not contain any error messages.
exec 2>&1


## do your script work commands here

SDATE1=$(date +"%s")
COLS=$(tput cols)
pad " $SCRIPTNAME v$THISVERSION " "$COLS" "-" C
pad " $(date --date="@$SDATE1" +'%Y-%m-%d %H:%M:%S %z') " "$COLS" "-" C
for outpath in $SBBSFTNOUTBASE; do
  nopathpname=${outpath##*/}
  currentdomain=${nopathpname%%.*}
  extpname=$([[ "$nopathpname" = *.* ]] && echo ".${nopathpname##*.}" || echo ".$FTNDEFAULTZONE")
  pathext=${extpname#*.}
  # we only want the file names here so we can work out the FTN address
  # make sure we remove all extension case variations with sed
  flist=$(find "$outpath" -type f \( -iname '*.?ut' -o -iname '*.?lo' \) | sed -e "s/.[uU][tT]$\|.[lL][oO]$//g" | sort | uniq)
  # count systems with waiting outbound mail
  flistcnt=$(printf "%s" "$flist" | grep -c "^")
  if (( flistcnt > 0 )); then
    printf " %3s destination%s in %-10s%s\n" "$flistcnt" "$([ ! "$flistcnt" == 1 ] && echo "s")" "$currentdomain" "$([ "$pathext" != $FTNDEFAULTZONE ] && echo "z$pathext")"
    if [ -n "$flist" ]; then
      for hexaddr in $flist; do
        # find all case variations of BSO file extensions
        for ext in {o,O,h,H,c,C,d,D,i,I}{u,U}{t,T} {f,F,h,H,c,C,d,D,i,I}{l,L}{o,O}; do
          thisfile=$hexaddr$ext
          if [[ -f ${thisfile} ]]; then
            # is it a file or a directory?
            idx=$(strindex "$thisfile" .pnt)
            if (( idx == -1 )); then
              nopathfname=${thisfile##*/}
              noextfname=${nopathfname%.*}
              ftnaddress="$(printf "%d:%d/%d" 0x"$pathext" 0x"${noextfname:0:4}" 0x"${noextfname:4}")"
              # get the flo file type; f - normal, c - crash, h - hold, d - direct, i - immediate
              floext=${nopathfname#*.}
            else
              pntdir=$(basename "$(dirname "$thisfile")")
              noextpntdir=${pntdir%.*}
              nopathfname=${thisfile##*/}
              noextfname=${nopathfname%.*}
              ftnaddress="$(printf "%d:%d/%d.%d" 0x"$pathext" 0x"${noextpntdir:0:4}" 0x"${noextpntdir:4}" 0x"${noextfname:0:8}")"
              # get the flo file type; f - normal, c - crash, h - hold, d - direct, i - immediate
              floext=${nopathfname#*.}
            fi
            # make flotype lowercase for easy comparison
            flotype=$(echo "${floext:0:1}" | tr '[:upper:]' '[:lower:]')
            unset name
            unset namedt
            unset oldest
            if [[ -f ${thisfile} ]]; then
              # make thisfile lowercase for easy comparison
              if [ "$(echo "${thisfile: -2}" | tr '[:upper:]' '[:lower:]')" == ut ]; then
                outstr="netmail"
                for foo in "$hexaddr".?{l,L,o,O}; do
                  if [ ! -e "$foo" ]; then
                    # get waiting ?ut age only if there's no waiting ?lo
                    [ "${thisfile}" -ot "${oldest=$thisfile}" ] && oldest=${thisfile}
                    namedt=$(stat -c %Y "$oldest")
                  else
                    outstr=$outstr" and "
                  fi
                done
              fi
              # make thisfile lowercase for easy comparison
              if [ "$(echo "${thisfile: -2}" | tr '[:upper:]' '[:lower:]')" == lo ]; then
                # count the number of lines without leading "~" or "!"
                # see FTSC-5005 section 3.1 for their meaning and why
                # we are skipping them in this count
                waitingfiles=$(grep -cv "^(\~|\!)" "$thisfile")
                if [ ${#outstr} == 0 ]; then
                  outstr="$waitingfiles file"
                else
                  outstr="$outstr $waitingfiles file"
                fi
                if [ ! "$waitingfiles" == 1 ]; then
                  outstr=$outstr"s"
                fi
                # now let's actually read the list in the ?lo file and find the oldest of those files
                # make thisfile lowercase for easy comparison
                if [ "$(echo "${thisfile: -2}" | tr '[:upper:]' '[:lower:]')" == lo ]; then
                  while IFS= read -r name; do
                    # take into account sbbs tendency to write paths with leading ../
                    # so let's strip them first and replace with the sbbs root directory
                    # defined at the top of this script
                    if [ "${name::3}" == "^.." ] ; then
                      name=${name/^../$SBBSDIR}
                    fi
                    # see FTSC-5005 section 3.1 for the use of the following characters
                    # so you understand why we strip off them off the file names we're
                    # going to try to stat
                    if [[ ${name::1} == "^" || ${name::1} == "-" || ${name::1} == "#" || ${name::1} == "@" ]] ; then
                      # strip off the "^" or "#" and do not replace it at all
                      name=${name/^}
                      name=${name/-}
                      name=${name/#}
                      name=${name/@}
                    fi
                    # and finally if the first character is "~" or "!" then the file is already sent
                    # so don't try to count it
                    if [[ ! ${name::1} == "~" && ! ${name::1} == "!" ]] ; then
                      [ "${name}" -ot "${oldest=$name}" ] && oldest=${name}
                      namedt=$(stat -c %Y "$oldest")
                    fi
                  done < "$thisfile"  # while IFS= read
                fi
              fi
            fi
          fi
        done # for ext in
        # BSO files *.flo and *.out are normal flavor.
        # display their status as "-" and use all others as they are
        printf "%2s %-32s (%s) : $outstr" "$([ "$flotype" == "f" ] || [ "$flotype" == "o" ] && echo "-" || echo "$flotype")" "$ftnaddress@$currentdomain" "$noextfname"
        if [ -n "$namedt" ]; then
          printf " : "
          DIFF=$((SDATE1-namedt))
          elapsedtime $DIFF
        fi
        printf "\n"
        outstr=
        pntdir=
      done  # for hexaddr in $flist
    fi
  fi # if (( flistcnt > 0 ))
done
pad "-" "$COLS"
printf "\n"


## end of your script work commands
# clean up your variables
unset COLS
unset currentdomain
unset DIFF
unset ext
unset extpname
unset flist
unset flistcnt
unset floext
unset flotype
unset foo
unset ftnaddress
unset FTNDEFAULTZONE
unset hexaddr
unset idx
unset LOGFILE
unset namedt
unset noextfname
unset noextpntdir
unset nopathfname
unset nopathpname
unset oldest
unset outpath
unset outstr
unset pathext
unset pntdir
unset SBBSDIR
unset SBBSFTNOUTBASE
unset SCRIPTNAME
unset SDATE1
unset thisfile
unset THISVERSION
unset waitingfiles

# return to the directory we were in when we started the script
cd "$CWD" || exit
unset CWD

#declare -p | diff "$tmpfile" -
#rm -f "$tmpfile"
